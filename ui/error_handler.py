"""
Error Handler

Centralized error handling for the dashboard with user-friendly messages.
"""

import streamlit as st
from typing import Optional, Any
import traceback


class ErrorHandler:
    """Centralized error handling for dashboard components"""
    
    def __init__(self, debug_mode: bool = False):
        """
        Initialize error handler
        
        Args:
            debug_mode: Whether to show detailed error information
        """
        self.debug_mode = debug_mode
        
    def handle_upload_error(self, error: Exception, file_name: Optional[str] = None) -> None:
        """
        Handle file upload errors with user-friendly messages
        
        Args:
            error: The exception that occurred
            file_name: Name of the file that caused the error
        """
        import json
        
        if isinstance(error, json.JSONDecodeError):
            st.error("‚ùå Invalid JSON file. Please upload a valid Terraform plan JSON file.")
            st.info("üí° Make sure your file is a properly formatted JSON file generated by `terraform plan -out=plan.tfplan && terraform show -json plan.tfplan > plan.json`")
        elif isinstance(error, FileNotFoundError):
            st.error("‚ùå File not found. Please select a valid file.")
        elif isinstance(error, PermissionError):
            st.error("‚ùå Permission denied. Please check file permissions.")
        elif "size" in str(error).lower():
            st.error("‚ùå File too large. Please upload a smaller plan file.")
            st.info("üí° Try filtering your Terraform plan to reduce the file size.")
        else:
            st.error(f"‚ùå Error uploading file: {str(error)}")
            if file_name:
                st.info(f"üìÅ File: {file_name}")
            st.info("üí° Please ensure you're uploading a valid Terraform plan JSON file.")
            
        self._show_error_details(error)
        
    def handle_processing_error(self, error: Exception, context: str = "processing") -> None:
        """
        Handle plan processing errors with graceful degradation
        
        Args:
            error: The exception that occurred
            context: Context where the error occurred
        """
        if "risk assessment" in context.lower():
            st.warning(f"‚ö†Ô∏è Enhanced risk assessment failed, falling back to basic mode: {str(error)}")
            st.info("üí° Basic risk assessment will still provide core functionality.")
        elif "parsing" in context.lower():
            st.error(f"‚ùå Error parsing Terraform plan: {str(error)}")
            st.info("üí° Please ensure your plan file is generated with a compatible Terraform version.")
        elif "provider" in context.lower():
            st.warning(f"‚ö†Ô∏è Provider detection failed: {str(error)}")
            st.info("üí° Continuing with single-provider analysis.")
        elif "recommendation" in context.lower():
            st.warning(f"‚ö†Ô∏è Could not generate recommendations: {str(error)}")
            st.info("üí° Manual review of the plan details is recommended.")
        else:
            st.error(f"‚ùå Error during {context}: {str(error)}")
            st.info("üí° Some features may be unavailable. Try refreshing the page or uploading a different file.")
            
        self._show_error_details(error)
        
    def handle_visualization_error(self, error: Exception, chart_type: str = "chart") -> None:
        """
        Handle visualization errors with fallback options
        
        Args:
            error: The exception that occurred
            chart_type: Type of chart that failed to render
        """
        if "plotly" in str(error).lower() or "chart" in str(error).lower():
            st.warning(f"‚ö†Ô∏è Could not render {chart_type}. Displaying data in table format instead.")
            st.info("üí° Chart rendering may fail due to data format issues or missing dependencies.")
        elif "data" in str(error).lower() or "empty" in str(error).lower():
            st.info(f"üìä No data available for {chart_type}.")
            st.info("üí° This may be normal if your plan doesn't contain the relevant resource types.")
        elif "provider" in str(error).lower():
            st.warning(f"‚ö†Ô∏è Could not create provider {chart_type}. Multi-cloud features may be unavailable.")
            st.info("üí° Continuing with single-provider analysis.")
        else:
            st.error(f"‚ùå Error creating {chart_type}: {str(error)}")
            st.info("üí° The visualization could not be generated, but other dashboard features remain available.")
            
        self._show_error_details(error)
    
    def handle_table_error(self, error: Exception) -> None:
        """
        Handle data table creation errors
        
        Args:
            error: The exception that occurred
        """
        st.error(f"‚ùå Error creating resource table: {str(error)}")
        st.info("üí° The resource details table could not be generated. Raw data may still be available for download.")
        self._show_error_details(error)
    
    def handle_filter_error(self, error: Exception) -> None:
        """
        Handle filter application errors
        
        Args:
            error: The exception that occurred
        """
        st.warning("‚ö†Ô∏è Error applying filters. Showing unfiltered results.")
        st.info("üí° Try adjusting your filter selections or refreshing the page.")
        self._show_error_details(error)
        
    def handle_enhanced_features_error(self, error: Exception) -> None:
        """
        Handle enhanced features errors with fallback to basic mode
        
        Args:
            error: The exception that occurred
        """
        if isinstance(error, ImportError):
            st.warning("‚öôÔ∏è Enhanced multi-cloud features are not available.")
            st.info("üí° To enable enhanced features, ensure all provider files are in place. Continuing in basic mode.")
        else:
            st.warning(f"‚ö†Ô∏è Enhanced features encountered an error: {str(error)}")
            st.info("üí° Falling back to basic mode. Core functionality remains available.")
            
        self._show_error_details(error)
    
    def handle_import_fallback(self, feature_name: str, error: ImportError) -> bool:
        """
        Handle ImportError for enhanced features with graceful fallback
        
        Args:
            feature_name: Name of the feature that failed to import
            error: The ImportError that occurred
            
        Returns:
            bool: False to indicate enhanced features are not available
        """
        if self.debug_mode:
            st.warning(f"‚öôÔ∏è {feature_name} not available: {str(error)}")
        else:
            st.warning(f"‚öôÔ∏è {feature_name} not available - using basic mode")
        
        st.info("üí° To enable enhanced features, ensure all required dependencies are installed.")
        self._show_error_details(error)
        return False
    
    def handle_feature_degradation(self, feature_name: str, error: Exception, fallback_message: str = None) -> None:
        """
        Handle feature degradation with user-friendly messaging
        
        Args:
            feature_name: Name of the feature that failed
            error: The exception that occurred
            fallback_message: Optional custom fallback message
        """
        st.warning(f"‚ö†Ô∏è {feature_name} failed, falling back to basic functionality")
        
        if fallback_message:
            st.info(f"üí° {fallback_message}")
        else:
            st.info("üí° Core functionality remains available.")
            
        self._show_error_details(error)
    
    def get_safe_fallback_value(self, primary_value: Any, fallback_value: Any, context: str = "") -> Any:
        """
        Safely return a fallback value if primary value is None or causes issues
        
        Args:
            primary_value: The preferred value to use
            fallback_value: The fallback value if primary fails
            context: Context for error reporting
            
        Returns:
            Either the primary value or fallback value
        """
        try:
            if primary_value is not None:
                return primary_value
            else:
                if context and self.debug_mode:
                    st.info(f"üîÑ Using fallback value for {context}")
                return fallback_value
        except Exception as e:
            if context:
                st.warning(f"‚ö†Ô∏è Error accessing {context}, using fallback")
            self._show_error_details(e)
            return fallback_value
    
    def with_fallback(self, primary_func, fallback_func, context: str = "operation"):
        """
        Execute a function with automatic fallback on failure
        
        Args:
            primary_func: Primary function to try
            fallback_func: Fallback function if primary fails
            context: Context for error reporting
            
        Returns:
            Result from either primary or fallback function
        """
        try:
            return primary_func()
        except Exception as e:
            st.warning(f"‚ö†Ô∏è {context.title()} failed, using fallback approach")
            self._show_error_details(e)
            try:
                return fallback_func()
            except Exception as fallback_error:
                st.error(f"‚ùå Both primary and fallback {context} failed")
                self._show_error_details(fallback_error)
                return None
        
    def _show_error_details(self, error: Exception) -> None:
        """
        Show detailed error information in debug mode
        
        Args:
            error: The exception to show details for
        """
        if self.debug_mode:
            with st.expander("üîç Debug Information"):
                st.text(f"Error Type: {type(error).__name__}")
                st.text(f"Error Message: {str(error)}")
                st.text("Traceback:")
                st.code(traceback.format_exc())